<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Together - Ultimate Suite</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f0f2f5;
            --card-bg: white;
            --text-color: #333;
            --accent: #007bff;
            --msg-remote: #e4e6eb;
            --msg-local: #007bff;
        }

        /* --- THEMES --- */
        body.theme-hearts { --bg-color: #ffe6e6; --accent: #ff4d4d; background-image: url('data:image/svg+xml;utf8,<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><text x="5" y="15" font-size="10">‚ù§Ô∏è</text></svg>'); }
        body.theme-midnight { --bg-color: #121212; --card-bg: #1e1e1e; --text-color: #e0e0e0; --accent: #bb86fc; --msg-remote: #333; --msg-local: #bb86fc; }
        body.theme-ocean { --bg-color: #e0f7fa; --accent: #00838f; --card-bg: #ffffff; }

        body { font-family: 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; transition: background 0.5s; }
        
        /* SHAKE ANIMATION (BUZZ) */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .buzz-effect { animation: shake 0.5s; animation-iteration-count: 1; border: 2px solid red; }

        /* HEADER */
        header { padding: 10px 15px; background: var(--card-bg); display: flex; justify-content: space-between; align-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.05); z-index: 100; }
        .room-title { font-size: 1.1rem; font-weight: bold; border: none; background: transparent; color: var(--text-color); width: 150px; }

        /* MAIN LAYOUT */
        #main-container { display: flex; flex: 1; padding: 10px; gap: 10px; overflow: hidden; flex-direction: column; position: relative; }
        
        /* YOUTUBE SECTION */
        #yt-container { display: none; width: 100%; aspect-ratio: 16/9; background: black; border-radius: 12px; overflow: hidden; flex-shrink: 0; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        iframe { width: 100%; height: 100%; border: none; }

        /* VIDEO GRID */
        #video-area { position: relative; flex: 1; min-height: 200px; display: flex; gap: 10px; justify-content: center; align-items: center; transition: all 0.3s; }
        
        /* WHITEBOARD CANVAS */
        #whiteboard { position: absolute; top:0; left:0; width: 100%; height: 100%; z-index: 50; pointer-events: none; cursor: crosshair; }
        #whiteboard.active { pointer-events: auto; background: rgba(255,255,255,0.1); }

        .vid-wrapper { 
            position: relative; background: #000; border-radius: 15px; overflow: hidden; 
            width: 100%; max-width: 600px; aspect-ratio: 4/3; 
            display: flex; align-items: center; justify-content: center; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); transition: width 0.3s, height 0.3s;
            touch-action: none;
        }
        
        video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); background: #222; transition: filter 0.3s; }
        #remote-video { transform: scaleX(1); }
        
        /* FILTERS */
        .filter-noir { filter: grayscale(100%) contrast(120%); }
        .filter-sepia { filter: sepia(60%) contrast(110%); }
        .filter-ocean { filter: hue-rotate(180deg) contrast(110%); }
        .filter-cyber { filter: hue-rotate(280deg) saturate(200%); }
        .filter-blur { filter: blur(5px); }

        /* AUDIO VISUALIZER */
        .audio-viz { position: absolute; bottom: 0; left: 0; width: 100%; height: 30px; z-index: 5; opacity: 0.7; pointer-events: none; }

        /* Floating/Draggable Mode */
        .vid-wrapper.floating {
            position: absolute; width: 120px !important; height: 160px !important; z-index: 1000;
            border: 2px solid var(--accent); box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            right: 10px; top: 10px; cursor: grab;
        }
        .vid-wrapper.floating .vid-controls { display: none; }
        .vid-wrapper.floating:hover .vid-controls { display: flex; }

        /* CONTROLS OVERLAY */
        .name-tag { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 3px 8px; border-radius: 5px; font-size: 0.8rem; pointer-events: none; z-index: 6; }
        .vid-controls { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 60; } /* z-index > canvas */
        .btn-icon { background: rgba(0,0,0,0.5); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: 0.2s; }
        .btn-icon:hover { background: var(--accent); }
        .btn-icon.active { background: var(--accent); color: white; }

        /* BOTTOM PANEL */
        #bottom-panel { display: flex; gap: 10px; height: 40%; min-height: 250px; max-height: 400px; }
        #control-box { flex: 0 0 250px; background: var(--card-bg); padding: 15px; border-radius: 12px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        #chat-box-container { flex: 1; background: var(--card-bg); border-radius: 12px; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        #messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 8px; scroll-behavior: smooth; }
        .msg { padding: 8px 14px; border-radius: 18px; max-width: 80%; word-wrap: break-word; font-size: 0.95rem; line-height: 1.4; }
        .msg.local { background: var(--msg-local); color: white; align-self: flex-end; border-bottom-right-radius: 2px; }
        .msg.remote { background: var(--msg-remote); color: var(--text-color); align-self: flex-start; border-bottom-left-radius: 2px; }
        .msg img { max-width: 200px; border-radius: 10px; margin-top: 5px; cursor: pointer; }
        
        #typing-indicator { font-size: 0.75rem; color: #888; padding: 0 15px; height: 20px; font-style: italic; opacity: 0; transition: opacity 0.3s; }
        #chat-input-area { display: flex; padding: 10px; border-top: 1px solid rgba(0,0,0,0.1); align-items: center; gap: 8px; }
        input[type="text"] { flex: 1; padding: 10px 15px; border: 1px solid #ddd; border-radius: 25px; outline: none; background: var(--bg-color); color: var(--text-color); }
        .chat-btn { background: transparent; color: var(--accent); border: none; font-size: 1.2rem; cursor: pointer; padding: 5px; }

        .hidden { display: none !important; }
        button.action-btn { padding: 10px; border-radius: 8px; border: none; cursor: pointer; width: 100%; background: var(--bg-color); color: var(--text-color); font-weight: 600; text-align: left; display: flex; align-items: center; gap: 10px; transition: 0.2s; }
        button.action-btn:hover { background: #e0e0e0; }
        
        @media (max-width: 768px) {
            #bottom-panel { flex-direction: column-reverse; height: auto; flex: 1; }
            #control-box { display: none; position: absolute; bottom: 60px; left: 10px; width: 250px; z-index: 20; box-shadow: 0 -5px 20px rgba(0,0,0,0.2); }
            #control-box.active { display: flex; }
            #video-area { flex-direction: column; }
        }
    </style>
</head>
<body class="theme-hearts">
    
    <header>
        <input type="text" id="room-name-input" class="room-title" value="Private Space" onchange="syncRoomName()">
        <div style="display:flex; gap:10px; align-items:center;">
            <button class="btn-icon" id="wb-toggle" onclick="toggleWhiteboard()" title="Draw Mode"><i class="fas fa-pen"></i></button>
            <button class="btn-icon" onclick="clearWhiteboard()" title="Clear Drawing"><i class="fas fa-eraser"></i></button>
            <div style="width:1px; height:20px; background:#ccc; margin:0 5px;"></div>
            <button class="btn-icon" style="background:transparent; color:var(--text-color);" onclick="toggleMobileMenu()"><i class="fas fa-cog"></i></button>
        </div>
    </header>

    <div id="main-container">
        <div id="yt-container">
            <div id="player"></div>
        </div>

        <div id="video-area">
            <canvas id="whiteboard"></canvas> <div class="vid-wrapper" id="local-wrapper">
                <video id="local-video" autoplay muted playsinline></video>
                <canvas id="local-viz" class="audio-viz"></canvas> <div class="name-tag">Me</div>
                <div class="vid-controls">
                    <button class="btn-icon" onclick="applyFilter(this, 'local-video')" title="Magic Filter"><i class="fas fa-magic"></i></button>
                    <button class="btn-icon" onclick="switchCamera()" title="Flip Cam"><i class="fas fa-sync-alt"></i></button>
                    <button class="btn-icon" onclick="toggleMuteSelf(this)"><i class="fas fa-microphone"></i></button>
                    <button class="btn-icon" onclick="toggleCamSelf(this)"><i class="fas fa-video"></i></button>
                    <button class="btn-icon" onclick="toggleScreenShare()" title="Share Screen"><i class="fas fa-desktop"></i></button>
                    <button class="btn-icon" onclick="toggleFloat('local-wrapper')"><i class="fas fa-external-link-alt"></i></button>
                </div>
            </div>

            <div class="vid-wrapper" id="remote-wrapper">
                <video id="remote-video" autoplay playsinline></video>
                <div class="name-tag" id="remote-name-display">Partner</div>
                <div class="vid-controls">
                    <button class="btn-icon" onclick="applyFilter(this, 'remote-video')" title="Filter"><i class="fas fa-magic"></i></button>
                    <button class="btn-icon" onclick="togglePiP()" title="Picture-in-Picture"><i class="fas fa-clone"></i></button>
                    <button class="btn-icon" onclick="toggleMutePartner()"><i class="fas fa-volume-up" id="partner-vol-icon"></i></button>
                    <button class="btn-icon" onclick="toggleFloat('remote-wrapper')"><i class="fas fa-external-link-alt"></i></button>
                </div>
            </div>
        </div>

        <div id="bottom-panel">
            <div id="control-box">
                <div style="font-weight:bold; margin-bottom:10px;">Control Center</div>
                <input type="text" id="my-name-input" placeholder="Your Name" onblur="updateMyName()" style="width:100%; padding:8px; box-sizing:border-box; margin-bottom:10px;">
                
                <button class="action-btn" onclick="sendBuzz()"><i class="fas fa-bolt" style="color:#ffd700;"></i> BUZZ Partner</button>

                <select onchange="changeTheme(this.value)" style="width:100%; padding:8px; margin-top:5px; margin-bottom:5px;">
                    <option value="theme-hearts">‚ù§Ô∏è Hearts Theme</option>
                    <option value="theme-midnight">üåô Midnight Theme</option>
                    <option value="theme-ocean">üåä Ocean Theme</option>
                </select>

                <button class="action-btn" onclick="toggleYTInput()"><i class="fab fa-youtube"></i> Watch YouTube</button>
                <div id="yt-controls" class="hidden" style="padding:10px; background:#f9f9f9; border-radius:5px;">
                    <input type="text" id="yt-url" placeholder="Paste YouTube Link" style="width:100%; padding:5px; margin-bottom:5px;">
                    <button style="width:100%; background:var(--accent); color:white; border:none; padding:5px; border-radius:4px;" onclick="loadVideo()">Play</button>
                </div>

                <button class="action-btn" onclick="copyLink()"><i class="fas fa-link"></i> Copy Invite Link</button>
                <button class="action-btn" style="color:#d9534f;" onclick="clearHistory()"><i class="fas fa-trash"></i> Clear History</button>
            </div>

            <div id="chat-box-container">
                <div id="messages"></div>
                <div id="typing-indicator">Partner is typing...</div>
                <div id="chat-input-area">
                    <button class="chat-btn" onclick="document.getElementById('file-input').click()"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="file-input" class="hidden" onchange="handleFileUpload(this)">
                    <input type="text" id="msg-input" placeholder="Type a message..." onkeypress="handleEnter(event)" oninput="sendTyping()">
                    <button class="chat-btn" onclick="sendMessage()"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // --- GLOBAL VARIABLES ---
        let peer, conn, localStream, currentCall;
        let player; 
        let myName = localStorage.getItem('my_name') || "Me";
        let chatHistory = []; 
        let isScreenSharing = false;
        let typingTimeout;
        
        // Audio Context
        let audioCtx, analyser, dataArray;
        
        // Whiteboard
        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let isWhiteboardActive = false;
        let lastX = 0, lastY = 0;

        // DOM
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const msgsDiv = document.getElementById('messages');
        const typingInd = document.getElementById('typing-indicator');

        // --- INIT ---
        window.addEventListener('resize', resizeCanvas);
        function resizeCanvas() {
            canvas.width = document.getElementById('video-area').offsetWidth;
            canvas.height = document.getElementById('video-area').offsetHeight;
        }
        
        window.onload = () => {
            resizeCanvas();
            document.getElementById('my-name-input').value = myName;
            const savedTheme = localStorage.getItem('theme');
            if(savedTheme) changeTheme(savedTheme, false);
            loadChatHistory();
            startCamera();
        };

        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
                localStream = stream;
                localVideo.srcObject = stream;
                initVisualizer(stream);
                if(!peer) initPeer();
            } catch (err) { alert("Camera Error: " + err); }
        }

        // --- PEERJS ---
        function initPeer() {
            peer = new Peer(); 
            peer.on('open', (id) => {
                const urlParams = new URLSearchParams(window.location.search);
                const partnerId = urlParams.get('call');
                if (partnerId) connectToPartner(partnerId);
                else showSystemMsg("Welcome! Copy the link to invite your partner.");
            });
            peer.on('connection', (c) => { conn = c; setupConnection(); });
            peer.on('call', (call) => {
                currentCall = call;
                call.answer(localStream);
                call.on('stream', stream => remoteVideo.srcObject = stream);
            });
        }

        function connectToPartner(id) {
            conn = peer.connect(id);
            const call = peer.call(id, localStream);
            currentCall = call;
            call.on('stream', stream => remoteVideo.srcObject = stream);
            setupConnection();
        }

        function setupConnection() {
            conn.on('open', () => {
                showSystemMsg("Partner connected.");
                sendData('history_sync', chatHistory);
                sendData('name', myName);
            });
            conn.on('data', (data) => handleData(data));
        }

        function sendData(type, content) {
            if (conn && conn.open) conn.send({ type, content });
        }

        function handleData(data) {
            switch(data.type) {
                case 'chat': saveAndShowMsg(data.content, 'remote'); break;
                case 'file': showFile(data.content, 'remote'); break;
                case 'history_sync': mergeHistory(data.content); break;
                case 'buzz': triggerBuzz(); break;
                case 'draw': drawLine(data.content.x0, data.content.y0, data.content.x1, data.content.y1, data.content.color, false); break;
                case 'clear-wb': ctx.clearRect(0,0,canvas.width,canvas.height); break;
                case 'name': document.getElementById('remote-name-display').innerText = data.content; break;
                case 'theme': changeTheme(data.content, false); break;
                case 'typing': showTyping(); break;
                case 'yt-start': startYT(data.content); break;
                case 'yt-control': handleYTControl(data.content); break;
            }
        }

        // --- NEW FEATURES IMPLEMENTATION ---

        // 1. WHITEBOARD
        function toggleWhiteboard() {
            isWhiteboardActive = !isWhiteboardActive;
            const btn = document.getElementById('wb-toggle');
            const board = document.getElementById('whiteboard');
            if(isWhiteboardActive) {
                btn.classList.add('active');
                board.classList.add('active');
            } else {
                btn.classList.remove('active');
                board.classList.remove('active');
            }
        }

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            if(!isWhiteboardActive) return;
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || !isWhiteboardActive) return;
            drawAndEmit(e.offsetX, e.offsetY);
        });
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Touch Events
        canvas.addEventListener('touchstart', (e) => {
            if(!isWhiteboardActive) return;
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.touches[0].clientX - rect.left;
            lastY = e.touches[0].clientY - rect.top;
        });
        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing || !isWhiteboardActive) return;
            e.preventDefault(); // Stop scroll
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            drawAndEmit(x, y);
        });
        canvas.addEventListener('touchend', () => isDrawing = false);

        function drawAndEmit(x, y) {
            // Draw Locally
            drawLine(lastX, lastY, x, y, '#ff4d4d', true);
            // Send relative coords (0-1) so it works on any screen size
            const w = canvas.width;
            const h = canvas.height;
            sendData('draw', {
                x0: lastX/w, y0: lastY/h, x1: x/w, y1: y/h, color: '#ff4d4d'
            });
            [lastX, lastY] = [x, y];
        }

        function drawLine(x0, y0, x1, y1, color, isLocal) {
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.beginPath();
            // If remote, un-normalize coordinates
            if(!isLocal) {
                ctx.moveTo(x0 * w, y0 * h);
                ctx.lineTo(x1 * w, y1 * h);
            } else {
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        function clearWhiteboard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            sendData('clear-wb', true);
        }

        // 2. VIDEO FILTERS
        const filters = ['', 'filter-noir', 'filter-sepia', 'filter-ocean', 'filter-cyber', 'filter-blur'];
        function applyFilter(btn, vidId) {
            const vid = document.getElementById(vidId);
            let current = vid.dataset.filterIndex ? parseInt(vid.dataset.filterIndex) : 0;
            // remove old
            if(filters[current]) vid.classList.remove(filters[current]);
            // next
            current = (current + 1) % filters.length;
            if(filters[current]) vid.classList.add(filters[current]);
            vid.dataset.filterIndex = current;
        }

        // 3. BUZZ / NUDGE
        function sendBuzz() {
            triggerBuzz(); // Shake myself
            sendData('buzz', true); // Shake them
        }
        function triggerBuzz() {
            document.body.classList.add('buzz-effect');
            // Play Beep
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 200;
            osc.type = 'sawtooth';
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.5);
            setTimeout(() => {
                document.body.classList.remove('buzz-effect');
                osc.stop();
            }, 500);
        }

        // 4. PIP MODE
        async function togglePiP() {
            try {
                if (document.pictureInPictureElement) {
                    await document.exitPictureInPicture();
                } else {
                    await remoteVideo.requestPictureInPicture();
                }
            } catch (err) { alert("PiP not supported or failed: " + err); }
        }

        // 5. AUDIO VISUALIZER
        function initVisualizer(stream) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioCtx.createMediaStreamSource(stream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 64; // Low detail for performance
            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            drawVisualizer();
        }

        function drawVisualizer() {
            const vCanvas = document.getElementById('local-viz');
            const vCtx = vCanvas.getContext('2d');
            const w = vCanvas.width;
            const h = vCanvas.height;
            
            function render() {
                requestAnimationFrame(render);
                analyser.getByteFrequencyData(dataArray);
                vCtx.clearRect(0, 0, w, h);
                vCtx.fillStyle = 'rgba(0, 123, 255, 0.8)'; // Blue bars
                
                const barWidth = (w / dataArray.length) * 2.5;
                let x = 0;
                
                for(let i = 0; i < dataArray.length; i++) {
                    const barHeight = dataArray[i] / 4; // Scale down
                    vCtx.fillRect(x, h - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            render();
        }

        // --- STANDARD CHAT & UTILS ---
        function sendMessage() {
            const input = document.getElementById('msg-input');
            const txt = input.value.trim();
            if(!txt) return;
            saveAndShowMsg(txt, 'local');
            sendData('chat', txt);
            input.value = '';
        }

        function saveAndShowMsg(txt, type, timestamp = Date.now()) {
            if (chatHistory.some(m => m.text === txt && m.time === timestamp)) return;
            const msgObj = { text: txt, type: type, time: timestamp };
            chatHistory.push(msgObj);
            if(chatHistory.length > 200) chatHistory.shift();
            localStorage.setItem('chat_history', JSON.stringify(chatHistory));
            
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            div.innerText = txt;
            msgsDiv.appendChild(div);
            msgsDiv.scrollTop = msgsDiv.scrollHeight;
        }

        function handleFileUpload(input) {
            const file = input.files[0];
            if (!file || file.size > 5 * 1024 * 1024) return alert("File too large (Max 5MB)");
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = { name: file.name, type: file.type, data: e.target.result };
                showFile(data, 'local');
                sendData('file', data);
            };
            reader.readAsDataURL(file);
        }

        function showFile(fileData, type) {
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            if (fileData.type.startsWith('image/')) {
                div.innerHTML = `<div><i class="fas fa-image"></i> Img</div><img src="${fileData.data}" onclick="expandImage(this.src)">`;
            } else {
                div.innerHTML = `<a href="${fileData.data}" download="${fileData.name}" style="color:inherit;"><i class="fas fa-file"></i> ${fileData.name}</a>`;
            }
            msgsDiv.appendChild(div);
            msgsDiv.scrollTop = msgsDiv.scrollHeight;
        }

        function expandImage(src) {
            const w = window.open("");
            w.document.write(`<img src="${src}" style="width:100%">`);
        }

        // Screen Share
        async function toggleScreenShare() {
            if (isScreenSharing) {
                // Stop Sharing
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
                replaceVideoTrack(stream);
                localVideo.srcObject = stream;
                localStream = stream;
                isScreenSharing = false;
            } else {
                // Start Sharing
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                    replaceVideoTrack(screenStream);
                    localVideo.srcObject = screenStream;
                    screenStream.getVideoTracks()[0].onended = () => { if(isScreenSharing) toggleScreenShare(); };
                    isScreenSharing = true;
                } catch(err) { console.log("Cancelled"); }
            }
        }
        function replaceVideoTrack(newStream) {
            if (currentCall) {
                const videoTrack = newStream.getVideoTracks()[0];
                const sender = currentCall.peerConnection.getSenders().find(s => s.track.kind === 'video');
                if(sender) sender.replaceTrack(videoTrack);
            }
        }

        // Utils
        function showSystemMsg(txt) {
            const div = document.createElement('div');
            div.style.textAlign='center'; div.style.fontSize='0.8rem'; div.style.color='#888'; div.style.margin='10px 0';
            div.innerText = txt;
            msgsDiv.appendChild(div);
        }
        function sendTyping() { sendData('typing', true); }
        function showTyping() {
            typingInd.style.opacity = '1';
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => typingInd.style.opacity = '0', 2000);
        }
        function loadChatHistory() {
            const stored = localStorage.getItem('chat_history');
            if(stored) {
                chatHistory = JSON.parse(stored);
                chatHistory.forEach(m => {
                    const div = document.createElement('div');
                    div.className = `msg ${m.type}`;
                    div.innerText = m.text;
                    msgsDiv.appendChild(div);
                });
            }
        }
        function mergeHistory(remoteHist) {
             remoteHist.forEach(m => {
                const flipped = m.type === 'local' ? 'remote' : 'local';
                if (!chatHistory.some(existing => existing.time === m.time && existing.text === m.text)) {
                    chatHistory.push({ text: m.text, type: flipped, time: m.time });
                    saveAndShowMsg(m.text, flipped, m.time);
                }
            });
        }
        function clearHistory() {
            localStorage.removeItem('chat_history');
            chatHistory = [];
            msgsDiv.innerHTML = '';
        }
        function updateMyName() {
            myName = document.getElementById('my-name-input').value;
            localStorage.setItem('my_name', myName);
            sendData('name', myName);
        }
        function changeTheme(theme, broadcast=true) {
            document.body.className = theme;
            localStorage.setItem('theme', theme);
            if(broadcast) sendData('theme', theme);
        }
        function toggleFloat(id) {
            const el = document.getElementById(id);
            el.classList.toggle('floating');
            if(el.classList.contains('floating')) makeDraggable(el);
        }
        function makeDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            elmnt.onmousedown = dragMouseDown;
            elmnt.ontouchstart = dragMouseDown;
            function dragMouseDown(e) {
                e = e || window.event;
                pos3 = e.clientX || e.touches[0].clientX;
                pos4 = e.clientY || e.touches[0].clientY;
                document.onmouseup = closeDragElement;
                document.ontouchend = closeDragElement;
                document.onmousemove = elementDrag;
                document.ontouchmove = elementDrag;
            }
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                let clientX = e.clientX || e.touches[0].clientX;
                let clientY = e.clientY || e.touches[0].clientY;
                pos1 = pos3 - clientX;
                pos2 = pos4 - clientY;
                pos3 = clientX;
                pos4 = clientY;
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }
            function closeDragElement() {
                document.onmouseup = null; document.onmousemove = null; document.ontouchend = null; document.ontouchmove = null;
            }
        }
        function copyLink() {
            const url = window.location.href.split('?')[0] + '?call=' + peer.id;
            navigator.clipboard.writeText(url);
            alert("Invite Link Copied!");
        }
        function toggleMobileMenu() { document.getElementById('control-box').classList.toggle('active'); }
        function handleEnter(e) { if(e.key === 'Enter') sendMessage(); }
        
        // Video Controls
        async function switchCamera() {
             localStream.getTracks().forEach(t=>t.stop());
             // For simplicity, just re-request. In production, maintain state of facingMode.
             await startCamera();
             if(currentCall) {
                 const videoTrack = localStream.getVideoTracks()[0];
                 const sender = currentCall.peerConnection.getSenders().find(s => s.track.kind === 'video');
                 sender.replaceTrack(videoTrack);
             }
        }
        function toggleMuteSelf(btn) { localStream.getAudioTracks()[0].enabled = !localStream.getAudioTracks()[0].enabled; btn.classList.toggle('off'); }
        function toggleCamSelf(btn) { localStream.getVideoTracks()[0].enabled = !localStream.getVideoTracks()[0].enabled; btn.classList.toggle('off'); }
        function toggleMutePartner() { remoteVideo.muted = !remoteVideo.muted; document.getElementById('partner-vol-icon').className = remoteVideo.muted ? 'fas fa-volume-mute' : 'fas fa-volume-up'; }
        
        // YouTube
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', { height: '100%', width: '100%', playerVars: { 'autoplay': 1, 'controls': 1 }, events: { 'onStateChange': onPlayerStateChange } });
        }
        function toggleYTInput() { document.getElementById('yt-controls').classList.toggle('hidden'); }
        function loadVideo() {
            const url = document.getElementById('yt-url').value;
            let id = url.split('v=')[1] || url.split('youtu.be/')[1];
            if(id) {
                const amp = id.indexOf('&'); if(amp != -1) id = id.substring(0, amp);
                startYT(id);
                sendData('yt-start', id);
            }
        }
        function startYT(id) {
            document.getElementById('yt-container').style.display = 'block';
            player.loadVideoById(id);
        }
        let isRemoteChange = false;
        function onPlayerStateChange(event) {
            if (isRemoteChange) return;
            if (event.data === YT.PlayerState.PLAYING) sendData('yt-control', { action: 'play', time: player.getCurrentTime() });
            else if (event.data === YT.PlayerState.PAUSED) sendData('yt-control', { action: 'pause', time: player.getCurrentTime() });
        }
        function handleYTControl(data) {
            isRemoteChange = true;
            if (data.action === 'play') {
                if (Math.abs(player.getCurrentTime() - data.time) > 1) player.seekTo(data.time);
                player.playVideo();
            } else if (data.action === 'pause') {
                player.seekTo(data.time);
                player.pauseVideo();
            }
            setTimeout(() => { isRemoteChange = false; }, 500);
        }
    </script>
</body>
</html>
